<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL2 Render to Texture</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
<canvas id="glCanvas" width="1000" height="600"></canvas>
<canvas id="textCanvas" width="350" height="100"></canvas>
<script>
  const canvas = document.getElementById("glCanvas");
  const gl = canvas.getContext("webgl2");

  if (!gl) {
    alert("WebGL2 is not supported on this browser.");
    throw new Error("WebGL2 not supported.");
  }

  const textCanvasCtx = document.getElementById("textCanvas").getContext("2d");

  // Vertex shader for fullscreen quad
  const vertexShaderSource = `#version 300 es
    precision highp float;
    in vec2 a_position;
    out vec2 v_uv;
    void main() {
        v_uv = a_position * 0.5 + 0.5; // Map [-1, 1] to [0, 1]
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
    `;

  // Fragment shader for circles
  const fragmentShaderSource = `#version 300 es
    precision highp float;
    in vec2 v_uv;
    out vec4 fragColor;

    uniform vec2 u_resolution;
    uniform vec2 u_points[100];
    uniform int u_numPoints;
    uniform float u_circleRadius;

    void main() {
        vec2 uv = v_uv * u_resolution; // Convert to pixel coordinates
        vec4 color = vec4(0.0); // Default background color

        for (int i = 0; i < 100; i++) {
            if (i >= u_numPoints) break;
            vec2 point = u_points[i];
            float dist = distance(uv, point);
            if (dist < u_circleRadius) {
                float alpha = smoothstep(u_circleRadius, u_circleRadius - 1.0, dist);
                color += vec4(1.0, 0.0, 0.0, alpha); // Red circles with fade
            }
        }

        fragColor = color;
    }
    `;

  // Fragment shader to display texture
  const displayShaderSource = `#version 300 es
    precision highp float;
    in vec2 v_uv;
    out vec4 fragColor;

    uniform sampler2D u_texture;

    void main() {
        fragColor = texture(u_texture, v_uv);
    }
    `;

  // Compile shader function
  function compileShader(gl, source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Error compiling shader:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Create program function
  function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
    const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Error linking program:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    return program;
  }

  // Create shaders and programs
  const circleProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);
  const displayProgram = createProgram(gl, vertexShaderSource, displayShaderSource);

  // Fullscreen quad setup
  const quadVertices = new Float32Array([
    -1, -1,
    1, -1,
    -1,  1,
    1,  1,
  ]);
  const vao = gl.createVertexArray();
  const vbo = gl.createBuffer();

  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

  const aPosition = gl.getAttribLocation(circleProgram, "a_position");
  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aPosition);

  gl.bindVertexArray(null);

  // Create texture to render to
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Create framebuffer
  const framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Uniform locations
  const uResolution = gl.getUniformLocation(circleProgram, "u_resolution");
  const uPoints = gl.getUniformLocation(circleProgram, "u_points");
  const uNumPoints = gl.getUniformLocation(circleProgram, "u_numPoints");
  const uCircleRadius = gl.getUniformLocation(circleProgram, "u_circleRadius");
  const uTexture = gl.getUniformLocation(displayProgram, "u_texture");

  let frames = 0;
  let lastFpsTime = Date.now();

  function renderFps() {
    let curTime = Date.now();
    if (curTime - lastFpsTime >= 1000) {
      lastFpsTime = curTime;
      textCanvasCtx.clearRect(0, 0, textCanvasCtx.canvas.width, textCanvasCtx.canvas.height);
      textCanvasCtx.fillText("FPS: " + frames, 20, 20);
      textCanvasCtx.fillText("Points: " + points.length, 20, 40);
      frames = 0;
    }
    frames += 1;
  }

  // Set initial uniform values
  const points = [
    [200, 300],
    [400, 500],
    [600, 200],
  ];
  let pointsRendered = 0;

  // Render to texture
  function renderToTexture() {

    gl.useProgram(circleProgram);
    gl.uniform2fv(uPoints, points.flat());
    gl.uniform1i(uNumPoints, points.length);
    gl.uniform1f(uCircleRadius, 50.0);
    gl.uniform2f(uResolution, canvas.width, canvas.height);

    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(circleProgram);
    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  // Render texture to screen
  function renderToScreen() {
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(displayProgram);
    gl.bindVertexArray(vao);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(uTexture, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindVertexArray(null);
  }

  // Main render loop
  function render() {
    if (pointsRendered < points.length) {
      renderToTexture();
      pointsRendered = points.length;
    }
    renderToScreen();
    renderFps();
    requestAnimationFrame(render);
  }

  canvas.addEventListener("mousedown", (e) => {
    if (e.buttons == 1) {
      points.push([e.layerX, canvas.height - e.layerY]);
    }
  });

  render();
</script>
</body>
</html>
